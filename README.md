# Simple smart pointers

В этом задании вам предстоит реализовать два вида умных указателей, реализующих концепт [раздельного владения](https://stackoverflow.com/questions/13852710/single-vs-shared-ownership-meaning) объектом — сценарий, когда несколько объектов владеют одним ресурсом, и он не освобождается, пока его не "отпустит" последний владелец.
Подобные указатели нередко являются строительными блоками для структур с copy-on-write оптимизацией.

## Shared pointer

Данный указатель реализует раздельное владение через подсчёт количества ссылок на разделяемый ресурс. Каждая копия `shared-ptr` увеличивает количество владельцев ресурса на 1, а деструктор уменьшает количество на 1 и очищает ресурс в случае обнуления счётчика.

## Linked pointer

В отличие от предыдущего указателя, реализует раздельное владение за счёт связывания всех инстансов `linked-ptr` в список (откуда и название). Каждая копия `linked-ptr` подвязывается в список рядом со своим "прародителем", а в деструкторе отвязывается из списка. При этом, если `linked-ptr` был последним в списке, он освобождает за собой разделяемый ресурс. Важной особенностью данного умного указателя являет тот факт, что он сам никогда не делает динамических аллокаций.

## Детали публичного контракта

- Дефолтный конструктор обоих умных указателей должен создавать указатель, не владеющий ничем и ведущий себя по аналогии с нулевым. При этом:
  - для `shared-ptr`, должен предоставлять nothrow гарантию безопасности исключений;
  - для `linked-ptr`, гарантии зависят от гарантий deleter'а (о котором ниже).
- Копирующий конструктор и оператор присваивания обоих указателей должны работать за **О(1)**, а также:
  - для `shared-ptr`, предоставлять nothrow гарантию безопасности исключений;
  - для `linked-ptr`, гарантии, зависящие от гарантий deleter'а (о котором ниже).
- Каждый из указателей, помимо типа `T` (на который он указывает), также параметризован типом deleter'а `D` — функционального объекта, используемого для освобождения ресурса. Т.е. это тип, на инстансе которого можно вызвать `()` (например, потому что это класс с перегруженным `operator()`), передав в него `T*`. Примером такого класса является [std::default_delete](https://en.cppreference.com/w/cpp/memory/default_delete) &mdash; он просто вызывает `delete ptr`. Вам необходимо использовать переданный в конструкторе deleter для освобождения разделяемого ресурса.
- Как и обычные указатели, умные указатели должны поддерживать разумные неявные преобразования (при конструировании и присваивании), как, например, из указателя на наследника в указатель на предка. Такие преобразования должны быть возможны, если:
  - умный указатель &mdash; `linked-ptr` (реализация такого каста для `shared-ptr` с учётом поставленных условий сложнее и выходит за рамки этого задания);
  - возможен неявный каст между соответствующими (не умными) указателями;
  - deleter текущего указателя [можно сконструировать](https://en.cppreference.com/w/cpp/types/is_constructible) из deleter'а источника;
  - запрещается использовать концепты для реализации данных ограничений.
